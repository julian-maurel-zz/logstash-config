input {
    beats {
        port => "5044"
    }
}
filter {
	if [fields][log_type] == "catalina.out" {
		if "org.jahia.bin.Render: Rendered" in [message] {
			grok {
		       match => [ "message", "(?<timestamp_log>[0-9-]+ [0-9:]+,[0-9]+): (?<loglevel>[A-Za-z$_]+)%{SPACE}\[(?<threadname>[a-zA-Z\-0-9]+)\] (?<javaClass>[a-zA-Z\-0-9\.]+): Rendered \[%{URIPATH:pagePath}\] user=\[%{WORD:username}\] .* in \[%{INT:renderTime:int}ms\]%{GREEDYDATA:message}" ]
		    }
		    mutate {
		      add_field => { "jahialogtype" => "pageRendered" }
		    }		
	    } else if "Error code: 404" in [message] { 
	    	grok {
		       match => [ "message", "(?<timestamp_log>[0-9-]+ [0-9:]+,[0-9]+): (?<loglevel>[A-Za-z$_]+)%{SPACE}\[(?<threadname>[a-zA-Z\-0-9]+)\] (?<javaClass>[a-zA-Z\-0-9\.]+): \[Error code: 404]: [a-zA-Z ]+: %{URIPATH:pagePath}" ]
		    }
			mutate {
		      add_field => { "jahialogtype" => "error 404" }
		    }
	    } else if "Error code: 400" in [message] { 
	    	grok {
		       match => [ "message", "(?<timestamp_log>[0-9-]+ [0-9:]+,[0-9]+): (?<loglevel>[A-Za-z$_]+)%{SPACE}\[(?<threadname>[a-zA-Z\-0-9]+)\] (?<javaClass>[a-zA-Z\-0-9\.]+): \[Error code: 400]: %{GREEDYDATA:error}" ]
		    }
			mutate {
		      add_field => { "jahialogtype" => "error 400" }
		    }
	    } else if "[GC" in [message] or "[Full GC" in [message] { # should add non-timestamped GC management
	    	grok {
		       match => [ "message", "(?<timestamp_log>[0-9-]+T[0-9:\.]+\+[0-9]+): \[(?<gc_type>[a-zA-Z]+).*, (?<gcDuration>[0-9]+.[0-9]+) secs" ]
		    }
			mutate {
		      add_field => { "jahialogtype" => "GC" }
		    }
	    } else {
	    	grok {
		       match => [ "message", "(?<timestamp_log>[0-9-]+ [0-9:]+,[0-9]+): (?<loglevel>[A-Za-z$_]+)%{SPACE}\[(?<threadname>[a-zA-Z\-0-9]+)\] (?<javaClass>[a-zA-Z\-0-9\.]+)%{GREEDYDATA:message}" ]
		    }
			mutate {
		      add_field => { "jahialogtype" => "unknown" }
		    }
	    }
	  #  if "_grokparsefailure" in [tags] {
		#		drop { }
	#	}
	    date {
			match => [ "timestamp_log", "YYYY-MM-dd HH:mm:ss,SSS" ]
			target => "@timestamp"
		} 
	}
	 if [fields][log_type] != "catalina.out" {
	    drop { }
	  }
	if [fields][log_type] == "apache" {
      grok {
        match => { "message" => ["%{IPORHOST:[apache2][access][remote_ip]} - %{DATA:[apache2][access][user_name]} \[%{HTTPDATE:[apache2][access][time]}\] \"%{WORD:[apache2][access][method]} %{DATA:[apache2][access][url]} HTTP/%{NUMBER:[apache2][access][http_version]}\" %{NUMBER:[apache2][access][response_code]} %{NUMBER:[apache2][access][body_sent][bytes]}( \"%{DATA:[apache2][access][referrer]}\")?( \"%{DATA:[apache2][access][agent]}\")?",
          "%{IPORHOST:[apache2][access][remote_ip]} - %{DATA:[apache2][access][user_name]} \\[%{HTTPDATE:[apache2][access][time]}\\] \"-\" %{NUMBER:[apache2][access][response_code]} -" ] }
        remove_field => "message"
      }
      mutate {
        add_field => { "read_timestamp" => "%{@timestamp}" }
      }
      date {
        match => [ "[apache2][access][time]", "dd/MMM/YYYY:H:m:s Z" ]
        remove_field => "[apache2][access][time]"
      }
      useragent {
        source => "[apache2][access][agent]"
        target => "[apache2][access][user_agent]"
        remove_field => "[apache2][access][agent]"
      }
      geoip {
        source => "[apache2][access][remote_ip]"
        target => "[apache2][access][geoip]"
      }
    }
}
output {
    elasticsearch {
     hosts => [ "localhost:9200" ]
     index => "filebeat-%{+YYYY.MM.dd}"
    } 
}